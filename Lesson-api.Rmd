---
title: "Introduction to APIs: Types of APIa"
subtitle: "Building Secure, Scalable, Fault-Tolerant and Low-Latency APIs with Java & Spring Boot"
author: "Ngane Emmanuel"
date: "`r Sys.Date()`"
output:
  powerpoint_presentation:
    slide_level: 2
---

## Types of APIs

### Why Are There Different Types of APIs?

Different systems have different needs:

- Performance requirements
- Data complexity
- Real-time communication
- Scalability
- Ease of development
- Compatibility with existing tools

No single API style solves all problems perfectly.

---

### Public APIs (Open APIs)

- Exposed to external developers.
- Used by third-party applications.
- Usually secured with API keys, OAuth, or tokens.

Examples:
- Payment gateways
- Weather services
- Maps services
- Social media APIs

Characteristics:
- High security requirements
- Strong documentation
- Rate limiting
- Monitoring

---

### Private APIs (Internal APIs)

- Used only inside an organization.
- Connect internal services and systems.
- Often power microservices architectures.

Characteristics:
- Faster evolution
- Controlled access
- Less public documentation
- Optimized for internal performance

---

### Partner APIs

- Shared with selected partners.
- Access is restricted and governed by contracts.
- Used in B2B integrations.

Examples:
- Logistics integrations
- Banking integrations
- Enterprise data sharing

---

## API Styles (Architectural Styles)

### REST (Representational State Transfer)

Most common API style on the web.

Key characteristics:
- Uses HTTP methods (GET, POST, PUT, DELETE)
- Stateless communication
- Resources identified by URLs
- Uses JSON or XML payloads

Example:
```

GET /api/products/10

````

Benefits:
- Simple
- Scalable
- Cacheable
- Widely supported

Limitations:
- Can over-fetch or under-fetch data
- Multiple calls may be required

---

### GraphQL

Client specifies exactly what data it needs.

Example query:
```graphql
{
  user(id: 1) {
    name
    email
  }
}
````

Benefits:

* Precise data fetching
* Fewer network calls
* Strong schema validation

Limitations:

* More complex infrastructure
* Caching is harder
* Learning curve

---

### gRPC

High-performance binary protocol.

Characteristics:

* Uses Protocol Buffers
* Strong typing
* Very fast serialization
* Ideal for microservices

Benefits:

* Extremely fast
* Efficient network usage

Limitations:

* Not human-readable
* Browser support is limited
* Harder debugging

---

### WebSockets

Real-time bidirectional communication.

Use cases:

* Chat applications
* Live dashboards
* Multiplayer games
* Real-time monitoring

Benefits:

* Low latency
* Continuous connection

Limitations:

* More complex scaling
* Connection management overhead

---

### When to Use What?

* REST → Most web and mobile APIs
* GraphQL → Complex data requirements
* gRPC → High-performance internal services
* WebSockets → Real-time systems

There is no universal best choice.

---

## API Architecture

### Important Clarification

An API is **not just controllers**.
An API is a **full system composed of multiple layers** working together.

Most production APIs follow a **Layered Architecture**.

---

### Typical Layered Architecture

```
Client (Browser / Mobile App / Other Service)
        ↓
API Layer (Controllers)
        ↓
Business Logic Layer (Services)
        ↓
Data Access Layer (Repositories / DAOs)
        ↓
Database / External Services
```

Each layer has a clear responsibility.

---

### API Layer (Controller Layer)

Responsibilities:

* Receives HTTP requests
* Validates input
* Maps requests to business logic
* Returns HTTP responses
* Handles status codes and errors

In Spring Boot:

* Annotated with `@RestController`
* Defines endpoints

This layer should be thin.

---

### Business Logic Layer (Service Layer)

Responsibilities:

* Core business rules
* Validation logic
* Transactions
* Orchestration of multiple repositories or services
* Security checks (sometimes)

In Spring Boot:

* Annotated with `@Service`

This is where most application logic lives.

---

### Data Access Layer (Repository Layer)

Responsibilities:

* Interacts with the database
* Executes queries
* Maps entities to tables
* Handles persistence

In Spring Boot:

* Annotated with `@Repository`
* Uses JPA, JDBC, or other persistence tools

---

### External Dependencies

APIs often integrate with:

* Databases
* Message brokers
* Caches
* Third-party services
* Authentication providers

These dependencies must be handled carefully for reliability and performance.

---

## MVC vs Layered Architecture

### What Is MVC?

MVC stands for:

* Model
* View
* Controller

It is mainly used for **UI-based web applications**.

---

### Why MVC Is Not a Perfect Fit for APIs

* APIs usually do not return views.
* APIs return data (JSON/XML).
* The "View" concept does not really apply.
* Business logic should not live in controllers.

---

### How APIs Actually Use MVC Concepts

* Controller → API Layer
* Model → Data objects (DTOs, Entities)
* View → Not applicable in pure APIs

Most APIs evolve into **Layered Architecture**, not pure MVC.

---

### Correct Mental Model

Think in layers, not screens:

* API Layer
* Business Layer
* Data Layer
* Infrastructure Layer

This improves maintainability and scalability.

---

## Common Misconception: Endpoints vs API

### What Many People Think

> "The API is just the endpoints."

Example:

```
GET /users
POST /users
```

---

### What the API Actually Is

The API includes:

* Endpoints
* Validation rules
* Business logic
* Data models
* Error handling
* Security mechanisms
* Documentation
* Performance behavior
* Reliability behavior

Endpoints are just the **entry point**.

---

### Why This Matters

If you only focus on endpoints:

* Security becomes weak
* Performance suffers
* Scalability breaks
* Faults propagate easily

Real engineering happens behind the endpoints.

---

## Key Takeaways

* APIs come in multiple styles for different needs.
* REST is common, but not the only choice.
* APIs use layered architecture.
* MVC is not the same as API architecture.
* Endpoints are only part of an API.

---

## What Comes Next

Next video:

* Designing a very basic API
* Understanding controllers, services, repositories
* Creating a minimal Spring Boot project
* Seeing how layers interact

```